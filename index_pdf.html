<!DOCTYPE html>
<html class="no-js">
  <head>
    <meta charset="UTF-8" />
    <style type="text/css">

      body {
        overflow: hidden;
				margin: 0;
      }

      #prev {
        left: 40px;
      }

      #next {
        right: 40px;
      }

			.fullpage {
        position: absolute;
				top: 0;
				left: 0;
        width: 100%;
        height: 100%;
			}

      .arrow {
        position: absolute;
        top: 50%;
        margin-top: -32px;
        font-size: 64px;
        color: #E2E2E2;
        font-family: arial, sans-serif;
        font-weight: bold;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
      }

      .arrow:hover {
        color: #777;
      }

      .arrow:active {
        color: #000;
      }

			#overlay {
				background-color: rgba(80, 137, 255, 0);
			}

			#overlay.over {
				background-color: rgba(80, 137, 255, 0.2);
			}

			#hint {
				font-family: 'Indie Flower', cursive;
				font-size: 1.8em;
				display: flex;
		    justify-content: center;
		    align-items: center;
				width: 100%;
				height: 100%;
			}

			#pageim {
				height: 100%;
				display: block;
				margin: auto;
				border: 1px solid #DDD;
			}
    </style>
		<link href='https://fonts.googleapis.com/css?family=Indie+Flower' rel='stylesheet' type='text/css'>
    <!-- PDFJS Library -->
    <script src="js/pdf.js"></script>
  </head>
  <body onkeydown="keyEvent(event)">
		<div class="fullpage">
			<img src="" alt="" id="pageim" />
		</div>
		<div id="hint" class="fullpage">Drop a PDF file here...</div>
		<div id="overlay" class="fullpage"></div>
		<div id="prev" onclick="loadPrevPage();" class="arrow">‹</div>
		<div id="next" onclick="loadNextPage();"class="arrow">›</div>
    <script>
      'use strict'

			let EventEmitter = require('events')
			let Watchdog = require('ya-watchdog')
      let co = require('co')
			let wait = require('co-wait')

			const HQ_SCALE = 3.0
			const LQ_SCALE = 0.75

			let overlayElmt = document.getElementById('overlay')
			let hintElmt = document.getElementById('hint')

			// Viewport related
			let pageim = document.getElementById('pageim')

			function handleDragOver (e) {
        e.stopPropagation()
        e.preventDefault()
        e.dataTransfer.dropEffect = 'copy'
        overlayElmt.classList.add('over')
      }

      function handleDragLeave (e) {
        overlayElmt.classList.remove('over')
      }

			// PDF Page renderer
			class Renderer extends EventEmitter {
				constructor (pdfFile) {
					super()

					this._canvas = document.createElement('canvas')
					this._ctx = this._canvas.getContext('2d')

					this._idle = true
					this._nextJob = null
					this._lastJob = null

					let self = this
					co(function * () {
						self._book = yield PDFJS.getDocument(pdfFile)
						self._page = 0

						// Output some stats
						console.log(`Num pages = ${self._book.numPages}`)

						self._watchdog = new Watchdog(150)
						self._watchdog.on('timeout', function () {
							self._render()
						})

						self._pushRenderJob(HQ_SCALE)
						self._render()

						self.emit('ready')
					})
				}

				nextPage() {
					this._page++
					if (this._page >= this._book.numPages) this._page = this._book.numPages - 1 // Saturate
					this._pushRenderJob(LQ_SCALE)
					this._render()
				}

				prevPage() {
					this._page--
					if (this._page < 0) this._page = 0
					this._pushRenderJob(LQ_SCALE)
					this._render()
				}

				_upToDate() {
					return this._lastJob.page === this._page && this._lastJob.quality === HQ_SCALE
				}

				_pushRenderJob (quality) {
					this._nextJob = {
						page: this._page,
						quality: quality
					}
				}

				_render () {
					if (!this._idle) return

					if (this._nextJob === null) {
						if (this._upToDate()) return
						this._pushRenderJob(HQ_SCALE)
						this._watchdog.kick()
						return
					}

					let job = this._nextJob
					this._idle = false
					this._nextJob = null

					let self = this

					co(function * () {
						let p = yield self._book.getPage(job.page+1)
						let viewport = p.getViewport(job.quality)
						self._canvas.height = viewport.height
						self._canvas.width = viewport.width
						yield p.render({
							canvasContext: self._ctx,
							viewport: viewport
						})
						self.emit('data', self._canvas.toDataURL())
						self._idle = true
						self._lastJob = job

						// If there is any new job
						self._render()
					})
				}
			}

			let renderer = null

			function keyEvent (event) {
			  var key = event.keyCode
				if (key == 37) { // Left
					renderer.prevPage()
				} else if (key == 39) { // Right
					renderer.nextPage()
				}
			}

			function loadBook (path) {
				if (hintElmt) {
					hintElmt.parentNode.removeChild(hintElmt)
					hintElmt = null
				}

				renderer = new Renderer(path)
				renderer.on('data', function (data) {
					pageim.src = data
				})
			}

      function handleDrop (e) {
        e.stopPropagation()
				e.preventDefault()
				overlayElmt.classList.remove('over')
				loadBook(e.dataTransfer.files[0].path)
      }

			overlayElmt.addEventListener('dragover', handleDragOver, false)
			overlayElmt.addEventListener('dragleave', handleDragLeave, false)
      overlayElmt.addEventListener('drop', handleDrop, false)
    </script>
  </body>
</html>
